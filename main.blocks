<xml xmlns="http://www.w3.org/1999/xhtml">
  <variables></variables>
  <block type="pxt-on-start" x="0" y="0">
    <statement name="HANDLER">
      <block type="typescript_statement" editable="false">
        <mutation line0="namespace OC05 {" line1="    const PCA9685_I2C_ADDRESS = 0x78" line2="    const PCA9685_PRESCALE = 0xFE" line3="    const PCA9685_MODE1 = 0x00" line4="    const modeRegister1Default = 0x01" line5="    const modeRegister2 = 0x01" line6="    const modeRegister2Default = 0x04" line7="    const PCA9685_SLEEP = modeRegister1Default | 0x10;" line8="    const PCA9685_WAKE = modeRegister1Default &amp; 0xEF;" line9="    const PCA9685_RESTART = PCA9685_WAKE | 0x80;" line10="    const PCA9685_ALLON_L = 0xFA" line11="    const PCA9685_ALLON_H = 0xFB" line12="    const PCA9685_ALLOFF_L = 0xFC" line13="    const PCA9685_ALLOFF_H = 0xFD" line14="    const PCA9685_CHAN8_ON_L = 0x26" line15="    const PCA9685_CHAN8_ON_H = 0x27" line16="    const PCA9685_CHAN8_OFF_L = 0x28" line17="    const PCA9685_CHAN8_OFF_H = 0x29" line18="    const hexChars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']" line19="" line20="    export enum PinNum {" line21="" line22="        Pin1 = 1," line23="        Pin2 = 2," line24="        Pin3 = 3," line25="        Pin4 = 4," line26="        Pin5 = 5," line27="        Pin6 = 6," line28="        Pin7 = 7," line29="        Pin8 = 8," line30="    }" line31="" line32="    export enum ServoNum {" line33="        Servo1 = 1," line34="        Servo2 = 2," line35="        Servo3 = 3," line36="        Servo4 = 4," line37="        Servo5 = 5," line38="        Servo6 = 6," line39="        Servo7 = 7," line40="        Servo8 = 8," line41="    }" line42="" line43="    export class ServoConfigObject {" line44="        id: number;" line45="        pinNumber: number;" line46="        minOffset: number;" line47="        midOffset: number;" line48="        maxOffset: number;" line49="        position: number;" line50="    }" line51="" line52="    export const DefaultServoConfig = new ServoConfigObject();" line53="    DefaultServoConfig.pinNumber = -1" line54="    DefaultServoConfig.minOffset = 5" line55="    DefaultServoConfig.midOffset = 15" line56="    DefaultServoConfig.maxOffset = 25" line57="    DefaultServoConfig.position = 90" line58="" line59="    export class ServoConfig {" line60="        id: number;" line61="        pinNumber: number;" line62="        minOffset: number;" line63="        midOffset: number;" line64="        maxOffset: number;" line65="        position: number;" line66="        constructor(id: number, config: ServoConfigObject) {" line67="            this.id = id" line68="            this.init(config)" line69="        }" line70="" line71="        init(config: ServoConfigObject) {" line72="            this.pinNumber = config.pinNumber &gt; -1 ? config.pinNumber : this.id - 1" line73="            this.setOffsetsFromFreq(config.minOffset, config.maxOffset, config.midOffset)" line74="            this.position = -1" line75="        }" line76="" line77="        setOffsetsFromFreq(startFreq: number, stopFreq: number, midFreq: number = -1): void {" line78="            this.minOffset = startFreq // calcFreqOffset(startFreq)" line79="            this.maxOffset = stopFreq // calcFreqOffset(stopFreq)" line80="            this.midOffset = midFreq &gt; -1 ? midFreq : ((stopFreq - startFreq) / 2) + startFreq" line81="        }" line82="" line83="        config(): string[] {" line84="            return [" line85="                'id', this.id.toString()," line86="                'pinNumber', this.pinNumber.toString()," line87="                'minOffset', this.minOffset.toString()," line88="                'maxOffset', this.maxOffset.toString()," line89="                'position', this.position.toString()," line90="            ]" line91="        }" line92="    }" line93="" line94="    export class ChipConfig {" line95="        address: number;" line96="        servos: ServoConfig[];" line97="        freq: number;" line98="        constructor(address: number = PCA9685_I2C_ADDRESS, freq: number = 50) {" line99="            this.address = address" line100="            this.servos = [" line101="                new ServoConfig(1, DefaultServoConfig)," line102="                new ServoConfig(2, DefaultServoConfig)," line103="                new ServoConfig(3, DefaultServoConfig)," line104="                new ServoConfig(4, DefaultServoConfig)," line105="                new ServoConfig(5, DefaultServoConfig)," line106="                new ServoConfig(6, DefaultServoConfig)," line107="                new ServoConfig(7, DefaultServoConfig)," line108="                new ServoConfig(8, DefaultServoConfig)," line109="            ]" line110="            this.freq = freq" line111="            init(address, freq)" line112="        }" line113="    }" line114="" line115="    export const chips: ChipConfig[] = []" line116="" line117="    function calcFreqPrescaler(freq: number): number {" line118="        return (25000000 / (freq * 4096)) - 1;" line119="    }" line120="" line121="    function stripHexPrefix(str: string): string {" line122="        if (str.length === 2) {" line123="            return str" line124="        }" line125="        if (str.substr(0, 2) === '0x') {" line126="            return str.substr(-2, 2)" line127="        }" line128="        return str" line129="    }" line130="" line131="    function write(chipAddress: number, register: number, value: number): void {" line132="        const buffer = pins.createBuffer(2)" line133="        buffer[0] = register" line134="        buffer[1] = value" line135="        pins.i2cWriteBuffer(chipAddress, buffer, false)" line136="    }" line137="" line138="    export function getChipConfig(address: number): ChipConfig {" line139="        for (let i = 0; i &lt; chips.length; i++) {" line140="            if (chips[i].address === address) {" line141="" line142="                return chips[i]" line143="            }" line144="        }" line145="        const chip = new ChipConfig(address)" line146="        const index = chips.length" line147="        chips.push(chip)" line148="        return chips[index]" line149="    }" line150="" line151="    function calcFreqOffset(freq: number, offset: number) {" line152="        return ((offset * 1000) / (1000 / freq) * 4096) / 10000" line153="    }" line154="" line155="    /**" line156="     * Used to set the pulse range (0-4095) of a given pin on the PCA9685" line157="     * @param chipAddress [64-125] The I2C address of your PCA9685; eg: 64" line158="     * @param pinNumber The pin number (0-15) to set the pulse range on" line159="     * @param onStep The range offset (0-4095) to turn the signal on" line160="     * @param offStep The range offset (0-4095) to turn the signal off" line161="     */" line162="    //% block advanced=true" line163="    export function setPinPulseRange(pinNumber: PinNum = 0, onStep: number = 0, offStep: number = 2048, chipAddress: number = 0x40): void {" line164="        pinNumber = Math.max(0, Math.min(15, pinNumber))" line165="        const buffer2 = pins.createBuffer(2)" line166="        const pinOffset = 4 * pinNumber" line167="        onStep = Math.max(0, Math.min(4095, onStep))" line168="        offStep = Math.max(0, Math.min(4095, offStep))" line169="" line170="" line171="        // Low byte of onStep" line172="        write(chipAddress, pinOffset + PCA9685_CHAN8_ON_L, onStep &amp; 0xFF)" line173="" line174="        // High byte of onStep" line175="        write(chipAddress, pinOffset + PCA9685_CHAN8_ON_H, (onStep &gt;&gt; 8) &amp; 0x0F)" line176="" line177="        // Low byte of offStep" line178="        write(chipAddress, pinOffset + PCA9685_CHAN8_OFF_L, offStep &amp; 0xFF)" line179="" line180="        // High byte of offStep" line181="        write(chipAddress, pinOffset + PCA9685_CHAN8_OFF_H, (offStep &gt;&gt; 8) &amp; 0x0F)" line182="    }" line183="" line184="    function degrees180ToPWM(freq: number, degrees: number, offsetStart: number, offsetEnd: number): number {" line185="        // Calculate the offset of the off point in the freq" line186="        offsetEnd = calcFreqOffset(freq, offsetEnd)" line187="        offsetStart = calcFreqOffset(freq, offsetStart)" line188="        const spread: number = offsetEnd - offsetStart" line189="        const calcOffset: number = ((degrees * spread) / 180) + offsetStart" line190="        // Clamp it to the bounds" line191="        return Math.max(offsetStart, Math.min(offsetEnd, calcOffset))" line192="    }" line193="" line194="    /**" line195="     * Used to move the given servo to the specified degrees (0-180) connected to the PCA9685" line196="     * @param chipAddress [64-125] The I2C address of your PCA9685; eg: 64" line197="     * @param servoNum The number (1-16) of the servo to move" line198="     * @param degrees The degrees (0-180) to move the servo to" line199="     */" line200="    //% block" line201="    export function setServoPosition(servoNum: ServoNum = 1, degrees: number, chipAddress: number = PCA9685_I2C_ADDRESS): void {" line202="        const chip2 = getChipConfig(chipAddress)" line203="        servoNum = Math.max(1, Math.min(16, servoNum))" line204="        degrees = Math.max(0, Math.min(180, degrees))" line205="        const servo: ServoConfig = chip2.servos[servoNum - 1]" line206="        const pwm = degrees180ToPWM(chip2.freq, degrees, servo.minOffset, servo.maxOffset)" line207="        servo.position = degrees" line208="        return setPinPulseRange(servo.pinNumber, 0, pwm, chipAddress)" line209="    }" line210="" line211="    /**" line212="     * Used to set the rotation speed of a continous rotation servo from -100% to 100%" line213="     * @param chipAddress [64-125] The I2C address of your PCA9685; eg: 64" line214="     * @param servoNum The number (1-16) of the servo to move" line215="     * @param speed [-100-100] The speed (-100-100) to turn the servo at" line216="     */" line217="    //% block" line218="    export function setCRServoPosition(servoNum: ServoNum = 1, speed: number, chipAddress: number = PCA9685_I2C_ADDRESS): void {" line219="        const chip3 = getChipConfig(chipAddress)" line220="        const freq = chip3.freq" line221="        servoNum = Math.max(1, Math.min(16, servoNum))" line222="        const servo2: ServoConfig = chip3.servos[servoNum - 1]" line223="        const offsetStart = calcFreqOffset(freq, servo2.minOffset)" line224="        const offsetMid = calcFreqOffset(freq, servo2.midOffset)" line225="        const offsetEnd = calcFreqOffset(freq, servo2.maxOffset)" line226="        if (speed === 0) {" line227="            return setPinPulseRange(servo2.pinNumber, 0, offsetMid, chipAddress)" line228="        }" line229="        const isReverse: boolean = speed &lt; 0" line230="        const spread2 = isReverse ? offsetMid - offsetStart : offsetEnd - offsetMid" line231="        servo2.position = speed" line232="        speed = Math.abs(speed)" line233="        const calcOffset2: number = ((speed * spread2) / 100)" line234="        const pwm2 = isReverse ? offsetMid - calcOffset2 : offsetMid + calcOffset2" line235="        return setPinPulseRange(servo2.pinNumber, 0, pwm2, chipAddress)" line236="    }" line237="" line238="    /**" line239="     * Used to set the range in centiseconds (milliseconds * 10) for the pulse width to control the connected servo" line240="     * @param chipAddress [64-125] The I2C address of your PCA9685; eg: 64" line241="     * @param servoNum The number (1-16) of the servo to move; eg: 1" line242="     * @param minTimeCs The minimum centiseconds (0-1000) to turn the servo on; eg: 5" line243="     * @param maxTimeCs The maximum centiseconds (0-1000) to leave the servo on for; eg: 25" line244="     * @param midTimeCs The mid (90 degree for regular or off position if continuous rotation) for the servo; eg: 15" line245="     */" line246="    //% block advanced=true" line247="    export function setServoLimits(servoNum: ServoNum = 1, minTimeCs: number = 5, maxTimeCs: number = 2.5, midTimeCs: number = -1, chipAddress: number = PCA9685_I2C_ADDRESS): void {" line248="        const chip4 = getChipConfig(chipAddress)" line249="        servoNum = Math.max(1, Math.min(16, servoNum))" line250="        minTimeCs = Math.max(0, minTimeCs)" line251="        maxTimeCs = Math.max(0, maxTimeCs)" line252="        const servo3: ServoConfig = chip4.servos[servoNum - 1]" line253="        midTimeCs = midTimeCs &gt; -1 ? midTimeCs : ((maxTimeCs - minTimeCs) / 2) + minTimeCs" line254="        return servo3.setOffsetsFromFreq(minTimeCs, maxTimeCs, midTimeCs)" line255="    }" line256="" line257="    /**" line258="     * Used to setup the chip, will cause the chip to do a full reset and turn off all outputs." line259="     * @param chipAddress [64-125] The I2C address of your PCA9685; eg: 64" line260="     * @param freq [40-1000] Frequency (40-1000) in hertz to run the clock cycle at; eg: 50" line261="     */" line262="    //% block advanced=true" line263="    export function init(chipAddress: number = PCA9685_I2C_ADDRESS, newFreq: number = 50) {" line264="        const buf = pins.createBuffer(2)" line265="        const freq2 = (newFreq &gt; 1000 ? 1000 : (newFreq &lt; 40 ? 40 : newFreq))" line266="        const prescaler = calcFreqPrescaler(freq2)" line267="" line268="        write(chipAddress, PCA9685_MODE1, PCA9685_SLEEP)" line269="" line270="        write(chipAddress, PCA9685_PRESCALE, prescaler)" line271="" line272="        write(chipAddress, PCA9685_ALLON_L, 0x00)" line273="        write(chipAddress, PCA9685_ALLON_H, 0x00)" line274="        write(chipAddress, PCA9685_ALLOFF_L, 0x00)" line275="        write(chipAddress, PCA9685_ALLOFF_H, 0x00)" line276="" line277="        write(chipAddress, PCA9685_MODE1, PCA9685_WAKE)" line278="" line279="        control.waitMicros(1000)" line280="        write(chipAddress, PCA9685_MODE1, PCA9685_RESTART)" line281="    }" line282="" line283="    /**" line284="     * Used to reset the chip, will cause the chip to do a full reset and turn off all outputs." line285="     * @param chipAddress [64-125] The I2C address of your PCA9685; eg: 64" line286="     */" line287="    //% block" line288="    export function reset(chipAddress: number = PCA9685_I2C_ADDRESS): void {" line289="        return init(chipAddress, getChipConfig(chipAddress).freq);" line290="    }" line291="" line292="    /**" line293="     * Used to reset the chip, will cause the chip to do a full reset and turn off all outputs." line294="     * @param hexAddress The hex address to convert to decimal; eg: 0x40" line295="     */" line296="    //% block" line297="    export function chipAddress(hexAddress: string): number {" line298="        hexAddress = stripHexPrefix(hexAddress)" line299="        let dec = 0" line300="        let lastidx = 0" line301="        let lastchar = 0" line302="        const l = Math.min(2, hexAddress.length)" line303="        for (let j = 0; j &lt; l; j++) {" line304="            const char = hexAddress.charAt(j)" line305="            const idx = hexChars.indexOf(char)" line306="            const pos = l - j - 1" line307="            lastidx = pos" line308="            dec = dec + (idx * Math.pow(16, pos))" line309="        }" line310="        return dec" line311="    }" line312="}" numlines="313"></mutation>
        <comment pinned="false" h="80" w="160">OC05
% weight=90 color=#000000 icon="\uf085"
        </comment>
      </block>
    </statement>
  </block>
</xml>